[{"content":"通过JavaScript解析蓝牙指令及蓝牙返回数据 Raw指令存储格式 将ByteArray转换成HexString，根据指令类型及指令名称生成JSONObject。 服务器以JSON格式保存蓝牙指令。\n1 2 3 4 5 { \u0026#34;cmdType\u0026#34;: { \u0026#34;cmdName\u0026#34;: \u0026#34;HexString(蓝牙指令)\u0026#34; } } ByteArray 与 HexString互相转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Convert a hex string to a byte array function hexToBytes(hex) { for (var bytes = [], c = 0; c \u0026lt; hex.length; c += 2) bytes.push(parseInt(hex.substr(c, 2), 16)); return bytes; } // Convert a byte array to a hex string function bytesToHex(bytes) { for (var hex = [], i = 0; i \u0026lt; bytes.length; i++) { var current = bytes[i] \u0026lt; 0 ? bytes[i] + 256 : bytes[i]; hex.push((current \u0026gt;\u0026gt;\u0026gt; 4).toString(16)); hex.push((current \u0026amp; 0xF).toString(16)); } //设置分隔符号,转换成大写 return hex.join(\u0026#34;\u0026#34;).toUpperCase(); } JavaScript生成蓝牙指令 输入 参数 类型 是否必需 备注 cmdType String 是 设备类型、指令类型 cmdName String 是 指令名称 parameters JSONObject 否 指令参数，按需动态生成 1 2 3 4 5 6 7 { cmdType:\u0026#34;WoBlindTilt\u0026#34;, cmdName:\u0026#34;move\u0026#34;, parameters:{ percent:100 } } 解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 const cmdJson = \u0026#39;\u0026#39;; const cmdObj = JSON.parse(cmdJson); var CmdGenerator = (function() { function getCmd(request) { var requestJson = JSON.parse(request); var cmdType = requestJson.cmdType; var cmdName = requestJson.cmdName; var typeObj = cmdObj[cmdType]; if(typeObj == undefined) { return \u0026#34;no such cmdType: \u0026#34; + cmdType; } var rawCmd = typeObj[cmdName]; if(rawCmd == undefined) { return \u0026#34;no such cmdName: \u0026#34; + cmdName + \u0026#34; with cmdType: \u0026#34; + cmdType; } var parameters = requestJson.parameters; if(parameters != undefined) { return getByCmdType(cmdType,cmdName,parameters); } else { return bytesToHex(hexToBytes(rawCmd)); } } function getByCmdType(cmdType,cmdName,parameters) { var typeObj = cmdObj[cmdType]; switch(typeObj) { case cmdObj.WoBlindTilt: return getByBlindTiltCmdName(cmdName,parameters); default : return \u0026#34;no such cmdType: \u0026#34; + cmdType + \u0026#34; with parameters\u0026#34;; } } function getByBlindTiltCmdName(cmdName,parameters) { var rawCmd = cmdObj.WoBlindTilt[cmdName]; switch(rawCmd) { case cmdObj.WoBlindTilt.move: return getBlindTiltMoveCmd(rawCmd,parameters); case cmdObj.WoBlindTilt.setDirectionCmd: return getBlindTiltDirectionCmd(rawCmd,parameters); default: return \u0026#34;no such cmdName: \u0026#34; + cmdName + \u0026#34; with cmdType: WoBlindTilt\u0026#34; + \u0026#34; with parameters\u0026#34;; } } function getBlindTiltMoveCmd(rawCmd,parameters) { return rawCmd + hex8(parameters.percent); } function getBlindTiltDirectionCmd(rawCmd,parameters) { var data = parameters.direction | 0x02; return rawCmd + hex8(data); } function hexToBytes(hex) { for (var bytes = [], c = 0; c \u0026lt; hex.length; c += 2) bytes.push(parseInt(hex.substr(c, 2), 16)); return bytes; } function bytesToHex(bytes) { for (var hex = [], i = 0; i \u0026lt; bytes.length; i++) { var current = bytes[i] \u0026lt; 0 ? bytes[i] + 256 : bytes[i]; hex.push((current \u0026gt;\u0026gt;\u0026gt; 4).toString(16)); hex.push((current \u0026amp; 0xF).toString(16)); } return hex.join(\u0026#34;\u0026#34;).toUpperCase(); } function hex8(val) { val \u0026amp;= 0xFF; var hex = val.toString(16).toUpperCase(); return (\u0026#34;00\u0026#34; + hex).slice(-2); } return { getCmd: getCmd }; })(); 输出 原始指令（无需组装、拼接参数） HexString 组合指令 在JavaScript中组合后转换为HexString JavaScript解析蓝牙返回数据 获取设备返回的结果后，通过JavaScript解析数据\n输入 参数 类型 是否必需 备注 cmdType String 是 设备类型、指令类型 cmdName String 是 指令名称 input String 是 设备返回的结果 1 2 3 4 5 6 7 8 9 { cmdType:\u0026#34;WoBlindTilt\u0026#34;, cmdName:\u0026#34;move\u0026#34;, input:\u0026#34;0100000000\u0026#34; } 解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 var Parser = (function () { function parseToJSON(request) { var requestJson = JSON.parse(request); var cmdType = requestJson.cmdType; var cmdName = requestJson.cmdName; var typeObj = cmdObj[cmdType]; if (typeObj == undefined) { return \u0026#34;no such cmdType: \u0026#34; + cmdType; } var rawCmd = typeObj[cmdName]; if (rawCmd == undefined) { return \u0026#34;no such cmdName: \u0026#34; + cmdName + \u0026#34; with cmdType: \u0026#34; + cmdType; } var input = requestJson.input; if (input != undefined) { return parseByCmdType(cmdType, cmdName, input); } else { return \u0026#34;input undefined!\u0026#34;; } } function parseByCmdType(cmdType, cmdName, input) { var typeObj = cmdObj[cmdType]; switch (typeObj) { case cmdObj.WoBlindTilt: return parseByBlindTiltCmdName(cmdName, input); default: return \u0026#34;no such cmdType: \u0026#34; + cmdType + \u0026#34; with input\u0026#34;; } } function parseByBlindTiltCmdName(cmdName, input) { var rawCmd = cmdObj.WoBlindTilt[cmdName]; switch (rawCmd) { case cmdObj.WoBlindTilt.move: return parseBlindTiltMoveCmd(input); case cmdObj.WoBlindTilt.setDirectionCmd: return parseBlindTiltDirectionCmd(input); default: return \u0026#34;no such cmdName: \u0026#34; + cmdName + \u0026#34; with cmdType: WoBlindTilt\u0026#34; + \u0026#34; with input\u0026#34;; } } function parseBlindTiltMoveCmd(input) { var bytes = hexToBytes(input); var execCode = 0xff \u0026amp; bytes[0]; var percent = 0xff \u0026amp; bytes[1]; var output = {}; output.currentPosition = percent; var json = buildJSON(execCode); json.output = output; return JSON.stringify(json); } function parseBlindTiltDirectionCmd(input) { var bytes = hexToBytes(input); var execCode = 0xff \u0026amp; bytes[0]; var json = buildJSON(execCode); return JSON.stringify(json); } function buildJSON(execCode) { var json = {}; json.execCode = execCode; return json; } function hexToBytes(hex) { for (var bytes = [], c = 0; c \u0026lt; hex.length; c += 2) bytes.push(parseInt(hex.substr(c, 2), 16)); return bytes; } return { parseToJSON: parseToJSON }; })(); 输出 参数 类型 是否必需 备注 execCode int 是 指令执行状态 output JSONObject 否 返回数据，按需动态生成 executeCode\n0x01 1 OK执行完毕 0x02 2 ERROR执行出错 0x03 3 BUSY设备忙，请稍后重试 0x04 4 通信版本号不兼容 0x05 5 设备不支持此命令 0x06 6 设备电量低 0x07 7 设备已经加密（密钥已存在） 0x08 8 设备未加密 0x09 9 密码错误 0x0A 10 设备不支持这种加密方式 0x0B 11 找不到多跳设备 0x0C 12 连接网络失败 0x0D 13 当前模式下不支持此命令 0x0E 14 与需要保持连接的设备连接断开（从机离线返回0x0E） 0x0F 15 设置周期获取信息时Notify返回的命令执行状态（0x570E01） 示例\n1 2 3 4 5 6 7 8 9 10 11 { execCode:1, output:{ currentPosition:0 } } 整体流程 Android常用解析引擎 Rhino 不支持不全面，出现异常 Int8Array not defined； 未找到实现通过 JS 函数调用JS 函数的方法； 性能较低 包体积小 React Native 支持更全面 目前不需要单独集成 Android 调用 JS 方法待研究 J2V8 支持较新的标准 单独引入会显著增大app打包体积（15MB左右,包含armeabi、arm64）÷ ","date":"2022-08-14T15:16:47+08:00","permalink":"https://zole.life/p/javascript-in-android/","title":"JavaScript in Android"},{"content":"计划了解的内容 Data Binding Room Persistence ViewModel Handling Lifecycles LiveData Navigation Paging ","date":"2018-09-14T11:31:55Z","permalink":"https://zole.life/p/android-architecture-components-%E8%AE%A1%E5%88%92/","title":"Android Architecture Components 计划"},{"content":"背景 公司的APP之前一直是放在公司服务器，没有发布到应用市场，每次发布新版本用户更新都很麻烦。前段时间抽时间写了个应用内下载APK并更新的模块。 整个模块主要的几个类:\nUpgradeManager UpgradeService FileResponseBody ResponseInterceptor 网络请求使用的是Retrofit2+Rxjava2\nUpgradeManager 该类主要实现\n检查最新版本 升级信息提示 安装APK 删除冗余APK文件 检查最新版本 调用服务器提供的版本比对接口，将本地的版本名称提取出来封装为JSON字符串发送到服务器，根据服务器的返回结果做对应处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 private fun checkUpdate(context: Context, disposableObserver: DisposableObserver\u0026lt;UpdateAck\u0026gt;) { val pm = context.packageManager val versionName = pm.getPackageInfo(context.applicationInfo.packageName, 0).versionName val jsonObject = JSONObject() jsonObject.put(\u0026#34;versionName\u0026#34;, versionName) LogUtil.d(tag, jsonObject.toString()) RetrofitClient.removeMethod(API.METHOD.CHECK_UPDATE) val checkUpdateCall = RetrofitClient.apiService .checkNewVer(RetrofitClient.body(API.METHOD.CHECK_UPDATE, jsonObject.toString())) .compose(RetrofitClient.io2main()) .subscribeWith(disposableObserver) RetrofitClient.addMethod(javaClass.name, API.METHOD.CHECK_UPDATE, checkUpdateCall) } 下面贴出来的是手动检查升级的代码，无论是否需要升级都有相应提示，还需要一个backgroundCheck(context: Context)方法，在APP启动时调用，无需升级时不弹出提示打扰用户，代码就不贴了，只需省略部分提示代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 fun manualCheck(context: Context) { val disposableObserver = object : DisposableObserver\u0026lt;UpdateAck\u0026gt;() { override fun onComplete() {} override fun onNext(t: UpdateAck) { LogUtil.d(tag, t.toString()) val responseData = t.responseData if (t.result == \u0026#34;T\u0026#34; \u0026amp;\u0026amp; responseData != null) { //无错误信息 if (responseData.errorMessage.isBlank()) { //服务器存在不同版本 if (responseData.isNeedUpgrade) { val str = context.getString(R.string.need_upgrade) val msg = String.format(str, responseData.versionName) val upgradeVerName = \u0026#34;yourAppName\u0026#34; + responseData.versionName showDialog(context, msg, responseData.upgradeUrl, upgradeVerName) } else { val msg = context.getString(R.string.no_need_upgrade) showDialog(context, msg) } } else { showDialog(context, responseData.errorMessage) } } else { showDialog(context, t.errorMsg) } } override fun onError(e: Throwable) { LogUtil.e(tag, e.message.toString()) showDialog(context, context.getString(R.string.network_state)) } } checkUpdate(context, disposableObserver) } 升级信息提示 showDialog方法中为url和versionName参数设置了默认值null，当不是提示版本有版本需要更新时可以只传两个参数，这样能使代码看起来更简洁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private fun showDialog(context: Context?, msg: String, url: String? = null, versionName: String? = null) { //防止activity销毁后弹出提示导致程序崩溃 if (context != null) { val builder = AlertDialog.Builder(context) builder.setMessage(msg) .setPositiveButton(R.string.ok) { p0, _ -\u0026gt; p0.dismiss() //有新版本时启动更新流程 if (url != null) { if (!hasDownLoad(versionName!!)) { LogUtil.d(tag, \u0026#34;未下载$versionName\u0026#34; + \u0026#34;APK\u0026#34;) startDownLoadService(context, url, versionName) } else { LogUtil.d(tag, \u0026#34;已下载$versionName\u0026#34; + \u0026#34;APK\u0026#34;) installAPK(context, versionName) } } } .setNegativeButton(R.string.cancel) { p0, _ -\u0026gt; p0.dismiss() }.create().show() //通过EventBus通知AppInfo页面隐藏网络请求的旋转菊花 EventBus.getDefault().post(EventMsg.AppInfoDismissProgressBar()) } } 如果当前版本和服务器上的版本不一致时，先调用hasDownload(versionName!!)方法检查指定路径是否存在最新的APK文件\n1 2 3 4 5 6 7 fun hasDownLoad(versionName: String): Boolean { return apkFile(versionName).exists() } fun apkFile(versionName: String): File { return File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).absolutePath + \u0026#34;/\u0026#34; + versionName + \u0026#34;.apk\u0026#34;) } 如果存在则直接进行安装，如果没有最新版的APK文件，则通过 startDownLoadService(context, url, versionName)来开启UpgradeService进行后台下载。\n1 2 3 4 5 6 private fun startDownLoadService(context: Context, url: String, versionName: String) { val intent = Intent(context, UpgradeService::class.java) intent.putExtra(\u0026#34;url\u0026#34;, url) intent.putExtra(\u0026#34;versionName\u0026#34;, versionName) context.startService(intent) } 安装APK 安装代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private fun installAPK(context: Context, versionName: String) { val install = installIntent(context, versionName) context.startActivity(install) } fun installIntent(context: Context, versionName: String): Intent { val file = apkFile(versionName) //7.0关于读写文件有更严格的要求，需要配置FileProvider val uri = if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.N) { FileProvider.getUriForFile(context, \u0026#34;com.xxxxx.fileprovider\u0026#34;, file) } else { Uri.fromFile(file) } val install = Intent(Intent.ACTION_VIEW) install.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)//为7.0添加 install.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) install.setDataAndType(uri, \u0026#34;application/vnd.android.package-archive\u0026#34;) return install } 删除冗余APK文件 在启动页面调用 UpgradeManager.cleanOldApk(ctx)检查当前运行的APP版本和指定路径的APK versionName是否相同，相同则删除\n1 2 3 4 5 6 7 8 fun cleanOldApk(context: Context) { val pm = context.packageManager val locVersionName = pm.getPackageInfo(context.applicationInfo.packageName, 0).versionName //已下载的APK和当前安装的版本相同,删除下载的APK if (hasDownLoad(\u0026#34;yourAppName$locVersionName\u0026#34;)) { apkFile(\u0026#34;yourAppName$locVersionName\u0026#34;).delete() } } UpgradeService 该类主要实现\nAPK下载 保存 安装 通知中心更新下载进度 onCreate 初始化升级服务\n注册EventBus并发送粘性广播提示升级服务已启动 初始化通知中心对象，设置标题，信息，图标 1 2 3 4 5 6 7 8 9 10 11 12 13 14 override fun onCreate() { super.onCreate() LogUtil.d(tag, \u0026#34;onCreate\u0026#34;) EventBus.getDefault().register(this) EventBus.getDefault().postSticky(EventMsg.UpgradeServiceState(true)) notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager notificationBuilder = NotificationCompat.Builder(this, \u0026#34;upgrade\u0026#34;) notificationBuilder.setContentTitle(getString(R.string.notification_upgrade_title)) .setContentText(getString(R.string.notification_loading)) .setSmallIcon(R.mipmap.mainlancher) notificationBuilder.priority = PRIORITY_HIGH //点击后自动移除通知 notificationBuilder.setAutoCancel(true) } onStartCommand 开始下载 通过isDowloading和needDownLoad判断是否需要执行下载操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int { LogUtil.d(tag, \u0026#34;onStartCommand：startId$startId\u0026#34;) url = intent.getStringExtra(\u0026#34;url\u0026#34;) versionName = intent.getStringExtra(\u0026#34;versionName\u0026#34;) val needDownLoad = !UpgradeManager.hasDownLoad(versionName) if (!isDowloading \u0026amp;\u0026amp; needDownLoad) { retryCount = 0 downLoadAPK() } else { LogUtil.d(tag, \u0026#34;已有下载任务在执行！！！！\u0026#34;) } return super.onStartCommand(intent, flags, startId) } APK下载并保存并安装 downLoadAPK retryCount重试次数，目前设置的重试次数为7次。 下载开始后将isDowloading置为true 请求成功后调用saveFile(fileResponseBody: ResponseBody)读取数据写入本地\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private fun downLoadAPK() { //下载次数 retryCount++ LogUtil.d(tag, \u0026#34;开始下载\u0026#34;) RetrofitClient.removeMethod(\u0026#34;downloadAPK\u0026#34;) val downLoadCall = RetrofitClient.apiService.getApk(url) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.io()) .subscribeWith(object : DisposableObserver\u0026lt;ResponseBody\u0026gt;() { override fun onStart() { isDowloading = true } override fun onComplete() { LogUtil.d(tag, \u0026#34;onComplete\u0026#34;) } override fun onNext(t: ResponseBody) { LogUtil.d(tag, \u0026#34;onNext\u0026#34;) saveFile(t) } override fun onError(e: Throwable) { isDowloading = false LogUtil.e(tag, e.message.toString()) } }) RetrofitClient.addMethod(javaClass.name, \u0026#34;downloadAPK\u0026#34;, downLoadCall) } saveFile 写入文件到本地Download公共文件夹 期间若发生错误\n通过UpgradeManager.apkFile(versionName).delete()清除未下载完的文件 通过 updateNotification(R.string.notification_err_retry)更新通知中心提示 通过retryCount判断是否需要重试，超过重试上限则更新通知中心并调用stopSelf()停止服务 顺利保存到本地则调用installAPK()安装APK，并将isDowloading置为false\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 private fun saveFile(fileResponseBody: ResponseBody) { Observable.create\u0026lt;File\u0026gt; { e -\u0026gt; var inputStream: InputStream? = null var fileOutputStream: FileOutputStream? = null val buffer = ByteArray(2048) val apkFile = UpgradeManager.apkFile(versionName) LogUtil.d(tag, \u0026#34;保存文件到\u0026#34; + apkFile.absolutePath) try { inputStream = fileResponseBody.byteStream() fileOutputStream = FileOutputStream(apkFile) var len = inputStream!!.read(buffer) while (len != -1) { fileOutputStream.write(buffer, 0, len) len = inputStream.read(buffer) } fileOutputStream.flush() e.onNext(apkFile) } catch (err: IOException) { e.onError(err) } finally { inputStream?.close() fileOutputStream?.close() e.onComplete() } }.subscribeOn(Schedulers.io()) .observeOn(Schedulers.io()) .subscribe({ isDowloading = false installAPK() }, { e -\u0026gt; isDowloading = false LogUtil.e(tag, e.message.toString()) UpgradeManager.apkFile(versionName).delete() updateNotification(R.string.notification_err_retry) if (retryCount \u0026lt; 7) { downLoadAPK() } else { updateNotification(R.string.notification_err_retry_later) stopSelf() } }) } updateNotification(resId: Int)\n1 2 3 4 5 private fun updateNotification(resId: Int) { val string = getString(resId) notificationBuilder.setContentText(string) notificationManager.notify(0, notificationBuilder.build()) } installAPK 通过notificationBuilder.setProgress(0, 0, false)移除通知中的下载进度条 通过notificationBuilder.setContentIntent(pendingIntent)设置通知的点击响应，以便用户在安装界面点击了取消还能通过点击通知进行安装 通过 updateNotification(R.string.notification_load_complete)更新通知中心提示 执行安装 通过stopSelf()停止服务 1 2 3 4 5 6 7 8 9 private fun installAPK() { notificationBuilder.setProgress(0, 0, false) val install = UpgradeManager.installIntent(applicationContext, versionName) val pendingIntent = PendingIntent.getActivity(this, 0, install, PendingIntent.FLAG_UPDATE_CURRENT) notificationBuilder.setContentIntent(pendingIntent) updateNotification(R.string.notification_load_complete) startActivity(install) stopSelf() } onDestroy 停止所有当前类名相关网络请求 发送粘性广播通知更新服务已停止 注销EventBus 1 2 3 4 5 6 7 override fun onDestroy() { super.onDestroy() LogUtil.d(tag, \u0026#34;onDestroy\u0026#34;) RetrofitClient.removeAll(javaClass.name) EventBus.getDefault().postSticky(EventMsg.UpgradeServiceState(false)) EventBus.getDefault().unregister(this) } 下载进度百分比 下载进度更新通过EventBus+ResponseInterceptor+FileResponseBody实现\n自定义ResponseBody即下文的FileResponseBody，重写ResponseBody的fun source()方法，在该方法内获取当前下载进度并通过EventBus广播 自定义Interceptor即下文的ResponseInterceptor，将原ResponseBody替换为FileResponseBody以获取下载进度 在创建OkHttpClient的过程中通过addNetworkInterceptor(ResponseInterceptor())将自定义网络拦截器添加进去 在UpgradeService接收下载进度并更新到通知中心 1 2 3 4 5 6 7 8 9 10 @Subscribe(threadMode = ThreadMode.BACKGROUND) fun downloadProgress(event: EventMsg.FileLoading) { val progress = (event.bytesRead / event.contentLength) * 100 val progressStr = String.format(\u0026#34;%.2f\u0026#34;, progress) //以1%为步进，大量更新会导致通知中心下拉卡死 if (progressStr.endsWith(\u0026#34;00\u0026#34;)) { notificationBuilder.setProgress(100, progress.toInt(), false) notificationManager.notify(0, notificationBuilder.build()) } } FileResponseBody 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class FileResponseBody(private val originalResponse: Response) : ResponseBody() { private var bufferedSource: BufferedSource? = null init { LogUtil.d(\u0026#34;FileResponseBody init\u0026#34;) } override fun contentType(): MediaType? { return originalResponse.body()?.contentType() } override fun contentLength(): Long {// 返回文件的总长度，也就是进度条的max return originalResponse.body()!!.contentLength() } override fun source(): BufferedSource { if (bufferedSource == null) { bufferedSource = Okio.buffer(source(originalResponse.body()!!.source())) } return bufferedSource!! } private fun source(source: Source): Source { return object : ForwardingSource(source) { var totalBytesRead = 0L override fun read(sink: Buffer, byteCount: Long): Long { val bytesRead = super.read(sink, byteCount) // read() returns the number of bytes read, or -1 if this source is exhausted. totalBytesRead += if (bytesRead == -1L) 0 else bytesRead LogUtil.d(\u0026#34;readed:\u0026#34;, totalBytesRead.toString()) EventBus.getDefault().post(EventMsg.FileLoading(contentLength().toFloat(), totalBytesRead.toFloat())) return bytesRead } } } } ResponseInterceptor 1 2 3 4 5 6 7 8 9 10 11 12 13 private class ResponseInterceptor : Interceptor { override fun intercept(chain: Interceptor.Chain): Response { val request = chain.request() LogUtil.d(\u0026#34;request.url\u0026#34;, request.url().toString()) //地址为下载APK的地址时替换为FileResponseBody if (request.url().toString().startsWith(\u0026#34;http://www.******.com\u0026#34;)) { LogUtil.d(\u0026#34;new Response\u0026#34;) val response = chain.proceed(request) return response.newBuilder().body(FileResponseBody(response)).build() } return chain.proceed(request) } } ","date":"2018-05-19T10:07:55Z","permalink":"https://zole.life/p/android%E5%BA%94%E7%94%A8%E5%86%85%E4%B8%8B%E8%BD%BD%E5%B9%B6%E6%9B%B4%E6%96%B0apk/","title":"Android应用内下载并更新APK"},{"content":"Hello 使用Hexo和Github Pages搭建了这个简单的网站，稍微修改了点界面。后期会试着写一些Flutter学习过程中的文章。\n","date":"2018-05-10T00:00:00Z","permalink":"https://zole.life/p/%E5%B0%9D%E8%AF%95%E5%86%99%E5%86%99blog/","title":"尝试写写Blog"}]